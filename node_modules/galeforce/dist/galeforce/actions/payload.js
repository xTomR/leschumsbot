"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreatePayloadProxy = void 0;
const debug_1 = __importDefault(require("debug"));
const chalk_1 = __importDefault(require("chalk"));
const riot_api_1 = require("../../riot-api");
const payloadDebug = debug_1.default('galeforce:payload');
const payloadKeys = [
    '_id', 'type', 'method', 'endpoint', 'query', 'body',
    'region', 'summonerId', 'accountId', 'puuid', 'summonerName',
    'matchId', 'teamId', 'tournamentId', 'tournamentCode', 'championId',
    'leagueId', 'queue', 'tier', 'division', 'gameName', 'tagLine',
    'game', 'actId', 'version', 'locale', 'champion', 'skin', 'spell',
    'assetId', 'assetPath', 'lorSet', 'lorRegion', 'card',
];
const CreatePayloadProxy = (payload) => new Proxy(payload, {
    get: (target, name) => target[name],
    set: (target, name, value) => {
        payloadDebug(`${chalk_1.default.bold.magenta(target._id)} | ${chalk_1.default.cyan.bold(name)} ${chalk_1.default.dim(target[name])} \u279F %O`, value);
        switch (name) { // Handle special value checks for specific properties
            case 'region': { // Region check in case types are not followed
                const isLeagueRegion = Object.values(riot_api_1.LeagueRegion).includes(value);
                const isValorantRegion = Object.values(riot_api_1.ValorantRegion).includes(value);
                const isRiotRegion = Object.values(riot_api_1.RiotRegion).includes(value);
                const isLorRegion = Object.values(riot_api_1.LorRegion).includes(value);
                const isDataDragonRegion = Object.values(riot_api_1.DataDragonRegion).includes(value);
                switch (target.type) {
                    case 'lol':
                        if (!isLeagueRegion)
                            throw new Error('[galeforce]: Invalid /lol region provided.');
                        break;
                    case 'val':
                        if (!isValorantRegion)
                            throw new Error('[galeforce]: Invalid /val region provided.');
                        break;
                    case 'riot':
                        if (!isRiotRegion)
                            throw new Error('[galeforce]: Invalid /riot region provided.');
                        break;
                    case 'lor':
                        if (!isLorRegion)
                            throw new Error('[galeforce]: Invalid /lor region provided.');
                        break;
                    case 'lol-ddragon':
                    case 'lol-ddragon-buffer':
                        if (!isDataDragonRegion)
                            throw new Error('[galeforce]: Invalid Data Dragon region provided.');
                        break;
                    case 'lcu':
                    case 'gc':
                    case 'lor-ddragon':
                    case 'lor-ddragon-buffer':
                        break; // No region checks are required.
                    default: // No region check if an invalid type is present in the object
                        break;
                }
                break;
            }
            case 'queue': // Queue check in case types are not followed
                if (target.type === 'lol' && !Object.values(riot_api_1.LeagueQueue).includes(value)) {
                    throw new Error('[galeforce]: Invalid /lol queue type provided.');
                }
                else if (target.type === 'val' && !Object.values(riot_api_1.ValorantQueue).includes(value)) {
                    throw new Error('[galeforce]: Invalid /val queue type provided.');
                }
                break;
            case 'tier': // Tier check in case types are not followed
                if (!Object.values(riot_api_1.Tier).includes(value)) {
                    throw new Error('[galeforce]: Invalid ranked tier provided.');
                }
                break;
            case 'division': // Division check in case types are not followed
                if (!Object.values(riot_api_1.Division).includes(value)) {
                    throw new Error('[galeforce]: Invalid ranked division provided.');
                }
                break;
            case 'game': // Game check in case types are not followed
                if (!Object.values(riot_api_1.Game).includes(value)) {
                    throw new Error('[galeforce]: Invalid game provided.');
                }
                break;
            case 'summonerId':
            case 'accountId':
            case 'puuid':
                if (typeof value !== 'string') {
                    throw new Error(`[galeforce]: ${name} must be a string.`);
                }
                // Enforce length requirements for summonerId, accountId, puuid as dictated by Riot specifications
                if (name === 'summonerId' && value.length > 63) {
                    throw new Error('[galeforce]: summonerId is invalid according to Riot specifications (length > 63).');
                }
                else if (name === 'accountId' && value.length > 56) {
                    throw new Error('[galeforce]: accountId is invalid according to Riot specifications (length > 56).');
                }
                else if (name === 'puuid' && value.length > 78) {
                    throw new Error('[galeforce]: puuid is invalid according to Riot specifications (length > 78).');
                }
                break;
            case 'version':
                if (typeof value !== 'string') {
                    throw new Error(`[galeforce]: ${name} must be a string.`);
                }
                // Regex check of valid League of Legends versions
                if ((target.type === 'lol-ddragon' || target.type === 'lol-ddragon-buffer') && !(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/.test(value)) && !(/^lolpatch_([0-9]+)\.([0-9]+)$/.test(value))) {
                    throw new Error(`[galeforce]: Invalid ${name} provided (failed regex check).`);
                }
                else if ((target.type === 'lor-ddragon' || target.type === 'lor-ddragon-buffer') && !(/^([0-9]+)_([0-9]+)_([0-9]+)$/.test(value)) && value !== 'latest') { // Regex check valid Legends of Runeterra versions
                    throw new Error(`[galeforce]: Invalid ${name} provided (failed regex check).`);
                }
                break;
            case 'locale':
                if (typeof value !== 'string') {
                    throw new Error(`[galeforce]: ${name} must be a string.`);
                }
                // Regex check of valid locale formats for League of Legends and Legends of Runeterra
                if ((target.type === 'lol-ddragon' || target.type === 'lol-ddragon-buffer') && !(/^[a-z]{2}_[A-Z]{2}$/.test(value))) {
                    throw new Error(`[galeforce]: Invalid ${name} provided (failed regex check).`);
                }
                else if ((target.type === 'lor-ddragon' || target.type === 'lor-ddragon-buffer') && !(/^[a-z]{2}_[a-z]{2}$/.test(value))) {
                    throw new Error(`[galeforce]: Invalid ${name} provided (failed regex check).`);
                }
                break;
            case 'assetPath':
                // Regex check for valid assetPaths
                if (typeof value !== 'string' || !(/^(\/.*)+$/.test(value))) {
                    throw new Error(`[galeforce]: Invalid ${name} provided (failed regex check).`);
                }
            default:
                // Throw an error if the key does not exist on the payload interface
                if (!payloadKeys.includes(name)) {
                    return false;
                }
        }
        target[name] = value;
        return true;
    },
    ownKeys: (target) => payloadKeys,
});
exports.CreatePayloadProxy = CreatePayloadProxy;
//# sourceMappingURL=payload.js.map